"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromRau = fromRau;
exports.toRau = toRau;
exports.fromUtf8 = fromUtf8;
exports.toUtf8 = toUtf8;
exports.isHexStrict = isHexStrict;
exports.hexToBytes = hexToBytes;
exports.validateAddress = validateAddress;

var _bech = _interopRequireDefault(require("bech32"));

var _bignumber = require("bignumber.js");

var _utf = require("utf8");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * fromRau is a function to convert Rau to Iotx.
 * @param rau number of Rau in string
 * @param unit unit converts to
 * @returns number of unit
 */
function fromRau(rau, unit) {
  return convert(rau, unit, "div");
}
/**
 * toRau is a function to convert various units to Rau.
 * @param num is the number of unit
 * @param unit is the unit to convert to Rau.
 * @returns number of Rau
 */


function toRau(num, unit) {
  return convert(num, unit, "multipliedBy");
}

function convert(num, unit, operator) {
  const rauBN = new _bignumber.BigNumber(num);

  switch (unit) {
    case "Rau":
      return num;

    case "KRau":
      // @ts-ignore
      return rauBN[operator](new _bignumber.BigNumber("1000")).toString(10);

    case "MRau":
      // @ts-ignore
      return rauBN[operator](new _bignumber.BigNumber("1000000")).toString(10);

    case "GRau":
      // @ts-ignore
      return rauBN[operator](new _bignumber.BigNumber("1000000000")).toString(10);

    case "Qev":
      // @ts-ignore
      return rauBN[operator](new _bignumber.BigNumber("1000000000000")).toString(10);

    case "Jing":
      // @ts-ignore
      return rauBN[operator](new _bignumber.BigNumber("1000000000000000")).toString(10);

    default:
      // @ts-ignore
      return rauBN[operator](new _bignumber.BigNumber("1000000000000000000")).toString(10);
  }
}
/**
 * Should be called to get hex representation of utf8 string
 *
 * @param value input string
 * @returns hex representation of input string
 */


function fromUtf8(value) {
  let eValue = (0, _utf.encode)(value);
  let hex = ""; // remove \u0000 padding from either side

  eValue = eValue.replace(/^(?:\u0000)*/, "");
  eValue = eValue.split("").reverse().join("");
  eValue = eValue.replace(/^(?:\u0000)*/, "");
  eValue = eValue.split("").reverse().join("");

  for (let i = 0; i < eValue.length; i++) {
    const code = eValue.charCodeAt(i);
    const n = code.toString(16);
    hex += n.length < 2 ? `0${n}` : n;
  }

  return `${hex}`;
}
/**
 * Should be called to get utf8 from it's hex representation
 *
 * @param hex hex string
 *
 * @returns ascii string representation of hex value
 */


function toUtf8(hex) {
  if (!isHexStrict(hex)) {
    throw new Error(`The parameter "${hex}" must be a valid HEX string.`);
  }

  let result = "";
  let code = 0;
  let eHex = hex; // remove 00 padding from either side

  eHex = eHex.replace(/^(?:00)*/, "");
  eHex = eHex.split("").reverse().join("");
  eHex = eHex.replace(/^(?:00)*/, "");
  eHex = eHex.split("").reverse().join("");
  const l = eHex.length;

  for (let i = 0; i < l; i += 2) {
    code = parseInt(eHex.substr(i, 2), 16);
    result += String.fromCharCode(code);
  }

  return (0, _utf.decode)(result);
}
/**
 * Check if string is HEX, requires a 0x in front
 *
 * @param hex to be checked
 * @returns is hex
 */


function isHexStrict(hex) {
  return /^(-)?[0-9a-f]*$/i.test(hex);
}
/**
 * Convert a hex string to a byte array
 *
 * @param hex string
 *
 * @returns  the byte array
 */


function hexToBytes(hex) {
  if (!isHexStrict(hex)) {
    throw new Error(`Given value "${hex}" is not a valid hex string.`);
  }

  const shex = hex.length % 2 ? `0${hex}` : hex;
  const bytes = [];

  for (let c = 0; c < shex.length; c += 2) {
    bytes.push(parseInt(shex.substr(c, 2), 16));
  }

  return new Uint8Array(bytes);
}
/**
 * validate address for iotex.
 *
 * @param address address
 *
 * @returns validate result
 */


function validateAddress(address) {
  try {
    const payload = _bech.default.decode(address);

    return payload.prefix === "io";
  } catch (e) {
    return false;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hY2NvdW50L3V0aWxzLnRzIl0sIm5hbWVzIjpbImZyb21SYXUiLCJyYXUiLCJ1bml0IiwiY29udmVydCIsInRvUmF1IiwibnVtIiwib3BlcmF0b3IiLCJyYXVCTiIsIkJpZ051bWJlciIsInRvU3RyaW5nIiwiZnJvbVV0ZjgiLCJ2YWx1ZSIsImVWYWx1ZSIsImhleCIsInJlcGxhY2UiLCJzcGxpdCIsInJldmVyc2UiLCJqb2luIiwiaSIsImxlbmd0aCIsImNvZGUiLCJjaGFyQ29kZUF0IiwibiIsInRvVXRmOCIsImlzSGV4U3RyaWN0IiwiRXJyb3IiLCJyZXN1bHQiLCJlSGV4IiwibCIsInBhcnNlSW50Iiwic3Vic3RyIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwidGVzdCIsImhleFRvQnl0ZXMiLCJzaGV4IiwiYnl0ZXMiLCJjIiwicHVzaCIsIlVpbnQ4QXJyYXkiLCJ2YWxpZGF0ZUFkZHJlc3MiLCJhZGRyZXNzIiwicGF5bG9hZCIsImJlY2gzMiIsImRlY29kZSIsInByZWZpeCIsImUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNBLE9BQVQsQ0FBaUJDLEdBQWpCLEVBQThCQyxJQUE5QixFQUFvRDtBQUN6RCxTQUFPQyxPQUFPLENBQUNGLEdBQUQsRUFBTUMsSUFBTixFQUFZLEtBQVosQ0FBZDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTRSxLQUFULENBQWVDLEdBQWYsRUFBNEJILElBQTVCLEVBQWtEO0FBQ3ZELFNBQU9DLE9BQU8sQ0FBQ0UsR0FBRCxFQUFNSCxJQUFOLEVBQVksY0FBWixDQUFkO0FBQ0Q7O0FBRUQsU0FBU0MsT0FBVCxDQUFpQkUsR0FBakIsRUFBOEJILElBQTlCLEVBQTRDSSxRQUE1QyxFQUFzRTtBQUNwRSxRQUFNQyxLQUFLLEdBQUcsSUFBSUMsb0JBQUosQ0FB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QTlCLENBQU47QUFDRDs7QUFFRCxRQUFNc0IsSUFBSSxHQUFHdEIsR0FBRyxDQUFDTSxNQUFKLEdBQWEsQ0FBYixHQUFrQixJQUFHTixHQUFJLEVBQXpCLEdBQTZCQSxHQUExQztBQUVBLFFBQU11QixLQUFLLEdBQUcsRUFBZDs7QUFDQSxPQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdGLElBQUksQ0FBQ2hCLE1BQXpCLEVBQWlDa0IsQ0FBQyxJQUFJLENBQXRDLEVBQXlDO0FBQ3ZDRCxJQUFBQSxLQUFLLENBQUNFLElBQU4sQ0FBV1QsUUFBUSxDQUFDTSxJQUFJLENBQUNMLE1BQUwsQ0FBWU8sQ0FBWixFQUFlLENBQWYsQ0FBRCxFQUFvQixFQUFwQixDQUFuQjtBQUNEOztBQUVELFNBQU8sSUFBSUUsVUFBSixDQUFlSCxLQUFmLENBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTSSxlQUFULENBQXlCQyxPQUF6QixFQUFtRDtBQUN4RCxNQUFJO0FBQ0YsVUFBTUMsT0FBTyxHQUFHQyxjQUFPQyxNQUFQLENBQWNILE9BQWQsQ0FBaEI7O0FBQ0EsV0FBT0MsT0FBTyxDQUFDRyxNQUFSLEtBQW1CLElBQTFCO0FBQ0QsR0FIRCxDQUdFLE9BQU9DLENBQVAsRUFBVTtBQUNWLFdBQU8sS0FBUDtBQUNEO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYmVjaDMyIGZyb20gXCJiZWNoMzJcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJiaWdudW1iZXIuanNcIjtcbmltcG9ydCB7IGRlY29kZSwgZW5jb2RlIH0gZnJvbSBcInV0ZjhcIjtcblxuLyoqXG4gKiBmcm9tUmF1IGlzIGEgZnVuY3Rpb24gdG8gY29udmVydCBSYXUgdG8gSW90eC5cbiAqIEBwYXJhbSByYXUgbnVtYmVyIG9mIFJhdSBpbiBzdHJpbmdcbiAqIEBwYXJhbSB1bml0IHVuaXQgY29udmVydHMgdG9cbiAqIEByZXR1cm5zIG51bWJlciBvZiB1bml0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUmF1KHJhdTogc3RyaW5nLCB1bml0OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gY29udmVydChyYXUsIHVuaXQsIFwiZGl2XCIpO1xufVxuXG4vKipcbiAqIHRvUmF1IGlzIGEgZnVuY3Rpb24gdG8gY29udmVydCB2YXJpb3VzIHVuaXRzIHRvIFJhdS5cbiAqIEBwYXJhbSBudW0gaXMgdGhlIG51bWJlciBvZiB1bml0XG4gKiBAcGFyYW0gdW5pdCBpcyB0aGUgdW5pdCB0byBjb252ZXJ0IHRvIFJhdS5cbiAqIEByZXR1cm5zIG51bWJlciBvZiBSYXVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUmF1KG51bTogc3RyaW5nLCB1bml0OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gY29udmVydChudW0sIHVuaXQsIFwibXVsdGlwbGllZEJ5XCIpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0KG51bTogc3RyaW5nLCB1bml0OiBzdHJpbmcsIG9wZXJhdG9yOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCByYXVCTiA9IG5ldyBCaWdOdW1iZXIobnVtKTtcbiAgc3dpdGNoICh1bml0KSB7XG4gICAgY2FzZSBcIlJhdVwiOlxuICAgICAgcmV0dXJuIG51bTtcbiAgICBjYXNlIFwiS1JhdVwiOlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIHJhdUJOW29wZXJhdG9yXShuZXcgQmlnTnVtYmVyKFwiMTAwMFwiKSkudG9TdHJpbmcoMTApO1xuICAgIGNhc2UgXCJNUmF1XCI6XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZXR1cm4gcmF1Qk5bb3BlcmF0b3JdKG5ldyBCaWdOdW1iZXIoXCIxMDAwMDAwXCIpKS50b1N0cmluZygxMCk7XG4gICAgY2FzZSBcIkdSYXVcIjpcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJldHVybiByYXVCTltvcGVyYXRvcl0obmV3IEJpZ051bWJlcihcIjEwMDAwMDAwMDBcIikpLnRvU3RyaW5nKDEwKTtcbiAgICBjYXNlIFwiUWV2XCI6XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZXR1cm4gcmF1Qk5bb3BlcmF0b3JdKG5ldyBCaWdOdW1iZXIoXCIxMDAwMDAwMDAwMDAwXCIpKS50b1N0cmluZygxMCk7XG4gICAgY2FzZSBcIkppbmdcIjpcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJldHVybiByYXVCTltvcGVyYXRvcl0obmV3IEJpZ051bWJlcihcIjEwMDAwMDAwMDAwMDAwMDBcIikpLnRvU3RyaW5nKDEwKTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIHJhdUJOW29wZXJhdG9yXShuZXcgQmlnTnVtYmVyKFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKSkudG9TdHJpbmcoMTApO1xuICB9XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQHBhcmFtIHZhbHVlIGlucHV0IHN0cmluZ1xuICogQHJldHVybnMgaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVV0ZjgodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBlVmFsdWUgPSBlbmNvZGUodmFsdWUpO1xuICBsZXQgaGV4ID0gXCJcIjtcblxuICAvLyByZW1vdmUgXFx1MDAwMCBwYWRkaW5nIGZyb20gZWl0aGVyIHNpZGVcbiAgZVZhbHVlID0gZVZhbHVlLnJlcGxhY2UoL14oPzpcXHUwMDAwKSovLCBcIlwiKTtcbiAgZVZhbHVlID0gZVZhbHVlXG4gICAgLnNwbGl0KFwiXCIpXG4gICAgLnJldmVyc2UoKVxuICAgIC5qb2luKFwiXCIpO1xuICBlVmFsdWUgPSBlVmFsdWUucmVwbGFjZSgvXig/OlxcdTAwMDApKi8sIFwiXCIpO1xuICBlVmFsdWUgPSBlVmFsdWVcbiAgICAuc3BsaXQoXCJcIilcbiAgICAucmV2ZXJzZSgpXG4gICAgLmpvaW4oXCJcIik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gZVZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgY29uc3QgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyBgMCR7bn1gIDogbjtcbiAgfVxuXG4gIHJldHVybiBgJHtoZXh9YDtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmdcbiAqXG4gKiBAcmV0dXJucyBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjgoaGV4OiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIWlzSGV4U3RyaWN0KGhleCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwYXJhbWV0ZXIgXCIke2hleH1cIiBtdXN0IGJlIGEgdmFsaWQgSEVYIHN0cmluZy5gKTtcbiAgfVxuXG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgY29kZSA9IDA7XG4gIGxldCBlSGV4ID0gaGV4O1xuXG4gIC8vIHJlbW92ZSAwMCBwYWRkaW5nIGZyb20gZWl0aGVyIHNpZGVcbiAgZUhleCA9IGVIZXgucmVwbGFjZSgvXig/OjAwKSovLCBcIlwiKTtcbiAgZUhleCA9IGVIZXhcbiAgICAuc3BsaXQoXCJcIilcbiAgICAucmV2ZXJzZSgpXG4gICAgLmpvaW4oXCJcIik7XG4gIGVIZXggPSBlSGV4LnJlcGxhY2UoL14oPzowMCkqLywgXCJcIik7XG4gIGVIZXggPSBlSGV4XG4gICAgLnNwbGl0KFwiXCIpXG4gICAgLnJldmVyc2UoKVxuICAgIC5qb2luKFwiXCIpO1xuXG4gIGNvbnN0IGwgPSBlSGV4Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpICs9IDIpIHtcbiAgICBjb2RlID0gcGFyc2VJbnQoZUhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGUocmVzdWx0KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBzdHJpbmcgaXMgSEVYLCByZXF1aXJlcyBhIDB4IGluIGZyb250XG4gKlxuICogQHBhcmFtIGhleCB0byBiZSBjaGVja2VkXG4gKiBAcmV0dXJucyBpcyBoZXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGV4U3RyaWN0KGhleDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiAvXigtKT9bMC05YS1mXSokL2kudGVzdChoZXgpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBoZXggc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICpcbiAqIEBwYXJhbSBoZXggc3RyaW5nXG4gKlxuICogQHJldHVybnMgIHRoZSBieXRlIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleDogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGlmICghaXNIZXhTdHJpY3QoaGV4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgR2l2ZW4gdmFsdWUgXCIke2hleH1cIiBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLmApO1xuICB9XG5cbiAgY29uc3Qgc2hleCA9IGhleC5sZW5ndGggJSAyID8gYDAke2hleH1gIDogaGV4O1xuXG4gIGNvbnN0IGJ5dGVzID0gW107XG4gIGZvciAobGV0IGMgPSAwOyBjIDwgc2hleC5sZW5ndGg7IGMgKz0gMikge1xuICAgIGJ5dGVzLnB1c2gocGFyc2VJbnQoc2hleC5zdWJzdHIoYywgMiksIDE2KSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xufVxuXG4vKipcbiAqIHZhbGlkYXRlIGFkZHJlc3MgZm9yIGlvdGV4LlxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIGFkZHJlc3NcbiAqXG4gKiBAcmV0dXJucyB2YWxpZGF0ZSByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXlsb2FkID0gYmVjaDMyLmRlY29kZShhZGRyZXNzKTtcbiAgICByZXR1cm4gcGF5bG9hZC5wcmVmaXggPT09IFwiaW9cIjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIl19